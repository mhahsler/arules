\name{ruleInduction}
\alias{ruleInduction}
\alias{ruleInduction,itemsets-method}
\title{Rule Induction from Itemsets}
\description{
   Provides the generic function and the needed S4 method to
   induce all rules which can be generated by the given set of itemsets
   from a transactions dataset. This method can be used to create
   closed association rules.
}
\usage{
ruleInduction(x, ...)
\S4method{ruleInduction}{itemsets}(x, transactions, confidence = 0.8, 
    control = NULL)
}
\arguments{
  \item{x}{ the set of itemsets from which rules will be induced. }
  \item{\dots}{ further arguments. }
  \item{transactions}{ the transaction dataset used to mine 
  	the itemsets. Can be omitted if \code{x} contains a  
  	(complete set) of frequent itemsets together with their support counts. }
  \item{confidence}{a numeric value giving the minimum confidence for the
    rules. }  
  \item{control}{a named list with elements
      \code{method} indicating the method (\code{"ptree"} or \code{"apriori"}),
     and the logical arguments \code{reduce} and
    \code{verbose} to indicate if unused items are removed and if
    the output should be verbose.
    The default is method \code{"ptree"} with reduce \code{TRUE} and verbose \code{FALSE}.}
    }
\details{
  For the default method, control with \code{method = "ptree"}, no transactions are
  needed if \code{x} contains a complete set of frequent or closed itemsets. 
  Support counts are stored in a ptree and then retrieved to create rules and 
  calculate support. This is very fast. 
  If \code{x} is incomplete, transactions need to be specified.
  To improve speed, control \code{reduce = TRUE} is used to remove unused items
  from the transaction data before creating the ptree. This might be slower for large
  transaction data sets. However, this is highly recommended as the items are also 
  reordered to reduce the counting time.
  
  For \code{method = "apriori"}, transactions are always required. 
  Here, all rules are mined from the transactions
  data set using Apriori with the minimal support found in itemsets.
  And in a second step all rules which do not stem from one of the
  itemsets are removed. This procedure will be in many cases very slow
  (e.g., for itemsets with many elements or very low support).

  For \code{transactions}, a set different to the data used for creating the
  original itemsets with a different support distribution can be used, however, 
  the new set has to conform in terms of items and their order.

  ruleInduction can be used to produce closed association rules defined by
  Pei et al. (2000) as rules \eqn{X -> Y} where both \eqn{X} and \eqn{Y}
  are closed frequent itemsets. See Example section for code.
  
}
\value{
   An object of class \code{rules}.
}
\references{
Michael Hahsler, Christian Buchta, and Kurt Hornik. Selective association rule
generation. \emph{Computational Statistics,} 23(2):303-315, April 2008. 

Jian Pei, Jiawei Han, Runying Mao. CLOSET: An Efficient Algorithm for Mining Frequent Closed Itemsets. ACM SIGMOD Workshop on Research Issues in
Data Mining and Knowledge Discovery (DMKD 2000).
}
\seealso{ \code{\link{itemsets-class}}, \code{\link{rules-class}}
\code{\link{transactions-class}}}
\author{Christian Buchta and Michael Hahsler}
\examples{
data("Adult")

## find all closed frequent itemsets
closed_is <- apriori(Adult, 
	parameter = list(target = "closed frequent itemsets", support = 0.4))
closed_is

## use rule induction to produce all closed association rules
closed_rules <- ruleInduction(closed_is, transactions = Adult, 
  control = list(verbose = TRUE))

## inspect the resulting closed rules
summary(closed_rules)
inspect(head(closed_rules, by = "lift"))

## get rules from frequent itemsets. Here, transactions does not need to be 
## specified for rule induction.
frequent_is  <- eclat(Adult, parameter = list(support = 0.4))
assoc_rules <- ruleInduction(frequent_is)
assoc_rules
inspect(head(assoc_rules))

## for itemsets that are not a complete set of frequent itemsets, 
## transactions need to be specified.
some_is <- sample(frequent_is, 10)
ruleInduction(some_is, transactions = Adult)
}
\keyword{models}
